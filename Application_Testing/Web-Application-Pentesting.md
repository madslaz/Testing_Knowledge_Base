## Enumeration & Brute Force
- Basic authentication: Straightforward login method which only requires a username and password. Easy to implement and manage on devices with limited processing capabilities.
  - Network devices, like routers, typically use basic authentication to control access to their administrative interfaces.
  - Session management and user tracking is not required or is managed differently.
  - Defined in RFC 7617, the credentials (username and password) should be transported as a base64-encoded string within the HTTP Authorization header.
    - Straightforward but not secure over non-HTTPS connection.  

`hydra -l admin -P /usr/share/wordlists/SecLists/Passwords/Common-Credentials/500-worst-passwords.txt -f 10.10.192.40  http-get /labs/basic_auth` - https://www.kali.org/tools/hydra/
- [`waybackurls`](https://github.com/tomnomnom/waybackurls) to dump all links saved in Wayback Machine.

## Session Management
- Attributes that may by added to cookie:
  - **Secure**: Indicates to browser that cookie may only be transmitted over verified HTTPS channels. If there are certificate errors or HTTP is used, the cookie value will not be transmitted.
  - **HTTPOnly**: Indicates to browser that the cookie value may not be read by client-side JavaScript.
  - **Expire**: Indicates to the browser when a cookie value will no longer be valid and should be removed.
  - **SameSite**: Indicates to the browser whether the cookie may be transmitted in cross-site requests to help protect against CSRF attacks.
    - SameSite="Lax" allows the cookies to be sent on some cross-site requests, while "Strict" never allows cookies to be sent on a cross-site request.
- Token-based session management is a relatively new concept. Instead of using browser's automatic cookie management featuries, it relies on client-side code for the process.
  - After authentication, the web application provides a token within the request body. Using client-side JavaScript code, this token is then stored in the browser's LocalStorage.
  - When a new request is made, JavaScript code must load the token from storage and attach it as a header.
  - More common types of tokens is JSON Web Tokens (JWT), which is passed through the `Authorization: Bearer` header. 

|Cookie-Session Management|Token-Based Session Management|
|-----------|-----------|
|Cookie is auto sent by browser with each request|Token has to be submitted as a header with each request using client-side JS|
|Cookie attributes can be used to enhance browser's protection of cookie|Tokens do not have automatic security protections enforced and should, therefore, be safeguarded against disclosures|
|Cookies can be vulnerable to conventional client-side attacks such as CSRF, where the browser is tricked into making a request on behalf of the user|As token is  not automatically added to any request and cannot be read from LocalStorage by other domains, conventional client-side attacks, such as CSRF, are blocked|
|As cookies are locked to a specific domain, it can be difficult to use them securely in decentralized web applications|Tokens work well in decentralized web applications, as they are managed through JS and can often contain all the information to verify the token itself|

- Insecure Session Transmission example: Insecure redirect where threat actor controls the URL where you redirect to post-authentication. Happened with Oracle's [SSO solution](https://krbtgt.pw/oracle-oam-10g-session-hijacking/)

## JSON Web Tokens
- APIs: Application Programming Interfaces. Popularity increased due to allowing the same server-side logic to be centralized and reused for all interfaces.
  - However, to match the rise of APIs, new session management had to happen. Cookie-based authentication for APIs doesn't work as well since the solution is then not agnostic for other interfaces. This is where token-based session management comes from.
  - Token-based session management: client-side code. After authentication, web application provides a token within the request body. Using client-side JS, this token is then stored in browser's LocalStorage.
  - When a new request is made, JS code must load the token from storage and attach it as a header. Most common type is JSON Web Tokens (JWTs), passed through `Authorization: Bearer` header.
  - ![image](https://github.com/user-attachments/assets/b7cfcf0c-932a-41a1-86e3-65803969520d)
    - Header: Indicates the type of token, which is JWT, as well as the signing algorithm.
    - Payload: Body of the token, which contain the claims. A claim is a piece of information provided for a specific entity. In JWTs, there are registered claims, which are claims predefined by the JWT standard and public or private claims.
      - The public and private claims are those which are defined by the developer.
    - Signature: Method for verifying token's authenticity. Signature is created by using the algorithm specific in the header of the JWT.
- Signing algorithms:
  - None: None algorithm means no algorithm is used for the signature. Effectively, this is a JWT without a signature, meaning that the verification of the claims provided in the JWT cannot be verified through the signature.
  - Symmetric Signing: A symmetric signing algorithm, such as HS265, creates the signature by appending a secret value to the header and body of the JWT before generating a hash value. Verification of the signature can be performed by any system that has knowledge of the secret key.
  - Asymmetric Signing: An asymmetric signing algorithm, such as RS256, creates the signature by using a private key to sign the header and body of the JWT. This is created by generating the hash and then encrypting the hash using the private key. Verification of the signature can be performed by any system that has knowledge of the public key associated with the private key that was used to create the signature.
- JWTs can be encrypted (JWEs), but the key power of JWTs comes from the signature. Once a JWT is signed, it can be sent to the client, who can use this JWT wherever needed.
  - Centralized authentication server that creates the JWTs used on several applications. Each application can then verify the signature of the JWT; if verified, the claims provided within the JWT can be trusted and acted upon.
- Vulnerabilities related to JSON Web Tokens
  - Potential sensitive information disclosure. For example, I received the following JWT: `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InVzZXIiLCJwYXNzd29yZCI6InBhc3N3b3JkMSIsImFkbWluIjowLCJmbGFnIjoiVEhNezljYzAzOWNjLWQ4NWYtNDVkMS1hYzNiLTgxOGM4MzgzYTU2MH0ifQ.TkIH_A1zu1mu-zu6_9w_R4FUlYadkyjmXWyD5sqWd5U`
    - When decoded from base64, the payload reveals the flag for the box and the user's password: `{"username":"user","password":"password1","admin":0,"flag":"THM{9cc039cc-d85f-45d1-ac3b-818c8383a560}"}`.
  - Second common mistake is not correctly verifying the signature. If the signature is not correctly verified, a threat actor may be able to forge a valid JWT token to gain access to another user's account.
    -  In this lab, removed third part of the JWT (the signature), leaving only the dot, and we saw that we were still authenticated. Signature is not being verified. Rare to see on normal APIs but often happens on server-to-server APIs. If threat actor has direct access to backend server, JWTs can be forged.
  - Another issue is supporting the `None` signing algorithm, which means no signature is used within the JWT. Suppose developers do not lock in signature algorithm or deny the `None` algorithm. You can simply change the algorithm specified in your JWT to `None` which would cause the library used for signature verification to always return true, thus allowing you to forge any claims.
- Cracking weak signature: `hashcat -m 16500 -a 0 jwt.txt jwt.secrets.list`

## HTTP Request Smuggling
- CL.TE: Content-Length/Transfer-Encoding. CL-TE, the attacker exploits discrepancies between how different servers (typically a frontend and backend server) prioritize these headers. For example:
  - The proxy uses Content-Length header to determine the end of the request.
  - The backend server uses the Transfer-Encoding header.
  - Because of this discrepancy, you can craft ambiguous requests. Imagine sending a request with both Content-Length and Transfer-Encoding headers. Frontend might use Content-Length header and think the request ends at a certain point due to the number of bytes. In contrast, the backend server, relying on the Transfer-Encoding header, might interpret the request differently, leading to unexpected behavior.
```
POST /search HTTP/1.1
Host: example.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /update HTTP/1.1
Host: example.com
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

isadmin=true
```
